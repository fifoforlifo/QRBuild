using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

using QRBuild.IO;

namespace QRBuild
{
    /// 
    public sealed class BuildGraph
    {
        //-- Public interface

        /// Execute the specified action on targets.
        /// This is how you kick off a Build.
        public BuildResults Execute(
            BuildAction action,
            BuildOptions buildOptions,
            IEnumerable<string> targetPaths,
            bool processDependencies)
        {
            Trace.TraceInformation("Execute {0}", action);
            Trace.TraceInformation("-----------");
            // TODO: trace targets

            BuildResults buildResults = new BuildResults();
            buildResults.Action = action;
            buildResults.ExecuteStartTime = DateTime.Now;

            buildResults.Success = UntimedExecute(
                action,
                buildOptions,
                targetPaths,
                processDependencies,
                buildResults);

            buildResults.ExecuteEndTime = DateTime.Now;
            return buildResults;
        }

        /// Force dependencies to be recomputed on the next call that
        /// requires it.  This is really only useful if you want to get
        /// timings for ComputeDependencies.
        /// Typical usage: do not call this!
        public void ResetDependencyGraph()
        {
            m_explicitDepsComputed = false;
        }

        /// Returns all files that are not generated by this BuildGraph.
        public ICollection<string> GetNonGeneratedFilePaths()
        {
            ComputeDependencies();
            if (!m_explicitDepsValid) {
                return null;
            }

            var inputs = new HashSet<string>();
            foreach (var kvp in m_buildFiles) {
                BuildFile buildFile = kvp.Value;
                if (!IsTargetGenerated(buildFile)) {
                    inputs.Add(buildFile.Path);
                }
            }
            return inputs;
        }

        /// Returns all files that are generated by this BuildGraph.
        /// This may be a very large collection.
        public ICollection<string> GetGeneratedFilePaths()
        {
            ComputeDependencies();
            if (!m_explicitDepsValid) {
                return null;
            }

            var inputs = new HashSet<string>();
            foreach (var kvp in m_buildFiles) {
                BuildFile buildFile = kvp.Value;
                if (IsTargetGenerated(buildFile)) {
                    inputs.Add(buildFile.Path);
                }
            }
            return inputs;
        }


        //-- Internal interface

        internal HashSet<BuildTranslation> Translations
        {
            get { return m_translations; }
        }

        /// Add a translation to the BuildGraph.
        /// BuildTranslation's constructor calls this, so that users don't have to.
        internal void Add(BuildTranslation translation)
        {
            m_translations.Add(translation);
            m_explicitDepsComputed = false;
        }

        internal HashSet<BuildFile> GetBuildFilesForPaths(IEnumerable<string> filePaths)
        {
            HashSet<BuildFile> buildFiles = new HashSet<BuildFile>();
            foreach (string filePath in filePaths) {
                string absFilePath = QRPath.GetCanonical(filePath);

                BuildFile buildFile;
                if (m_buildFiles.TryGetValue(absFilePath, out buildFile)) {
                    buildFiles.Add(buildFile);
                }
                else {
                    // TODO: trace warning 
                }
            }
            return buildFiles;
        }

        internal BuildFile CreateOrGetBuildFile(string filePath)
        {
            BuildFile buildFile;
            if (m_buildFiles.TryGetValue(filePath, out buildFile)) {
                return buildFile;
            }
            buildFile = new BuildFile(filePath);
            m_buildFiles[filePath] = buildFile;
            return buildFile;
        }


        //-- Helpers

        private static HashSet<BuildNode> GetBuildNodesForFiles(IEnumerable<BuildFile> files)
        {
            HashSet<BuildNode> result = new HashSet<BuildNode>();
            foreach (BuildFile file in files) {
                result.Add(file.BuildNode);
            }
            return result;
        }

        private static bool IsTargetGenerated(BuildFile buildFile)
        {
            bool result = (buildFile.BuildNode != null);
            return result;
        }

        private void AddExplicitInputDependencies(BuildTranslation translation)
        {
            foreach (string input in translation.ExplicitInputs) {
                BuildFile buildFile = CreateOrGetBuildFile(input);
                buildFile.Consumers.Add(translation.BuildNode);
                
                if (buildFile.BuildNode != null) {
                    //  Add the BuildNode that generates input to the current node's dependency list.
                    translation.BuildNode.Dependencies.Add(buildFile.BuildNode);
                }
            }
        }

        private bool AddExplicitOutputDependencies(BuildTranslation translation)
        {
            bool result = true;
            foreach (string output in translation.ExplicitOutputs) {
                BuildFile buildFile = CreateOrGetBuildFile(output);
                
                if (buildFile.BuildNode != null) {
                    Trace.TraceError("Target {0} claims to be generated by more than one Translation:\n\t{1}\n\t{2}\n",
                        buildFile.Path,
                        buildFile.BuildNode.Translation.BuildFileBaseName,
                        translation.BuildFileBaseName);
                    result = false;
                }
                else {
                    buildFile.BuildNode = translation.BuildNode;
                }
            }
            return result;
        }

        private bool TimedComputeDependencies(BuildResults buildResults)
        {
            buildResults.ComputeDependenciesStartTime = DateTime.Now;
            buildResults.DependenciesComputed = !m_explicitDepsComputed;
            ComputeDependencies();
            m_explicitDepsComputed = true;
            buildResults.ComputeDependenciesEndTime = DateTime.Now;
            return m_explicitDepsValid;
        }

        /// This function determines all BuildNodes' dependencies.
        /// Consumers are cleared here, to be decided later by the
        /// specific targets required of a BuildProcess.
        /// Call this after all Translations have been added.
        private void ComputeDependencies()
        {
            if (m_explicitDepsComputed) {
                return;
            }

            m_explicitDepsValid = false;
            bool result = true;

            //  Clear m_buildFiles, so that we only use the most recent
            //  inputs and outputs from each BuildTranslation.
            m_buildFiles.Clear();

            //  Clear stale dependency information, and set outputs' BuildNode references.
            foreach (BuildTranslation translation in m_translations) {
                translation.BuildNode.Dependencies.Clear();
                translation.BuildNode.Consumers.Clear();
                translation.BuildNode.Status = BuildStatus.NotStarted;

                if (translation.DepsCacheFilePath == null) {
                    Trace.TraceError("Translation {0} has null DepsCachePath.", translation.BuildFileBaseName);
                    return;
                }

                translation.UpdateExplicitIO();
                result &= AddExplicitOutputDependencies(translation);
            }

            //  Establish dependencies based on node inputs.
            foreach (BuildTranslation translation in m_translations) {
                AddExplicitInputDependencies(translation);
            }

            //  Establish consumers by reflecting the dependencies.
            foreach (BuildTranslation translation in m_translations) {
                foreach (BuildNode dependency in translation.BuildNode.Dependencies) {
                    dependency.Consumers.Add(translation.BuildNode);
                }
            }

            m_explicitDepsValid = result;
            return;
        }

        private bool UntimedExecute(
            BuildAction action,
            BuildOptions buildOptions,
            IEnumerable<string> targetPaths,
            bool processDependencies,
            BuildResults buildResults)
        {
            bool computeDependenciesSuccess = TimedComputeDependencies(buildResults);
            if (!computeDependenciesSuccess) {
                return false;
            }

            HashSet<BuildFile> targets = GetBuildFilesForPaths(targetPaths);

            HashSet<BuildNode> buildNodes = GetBuildNodesForFiles(targets);
            if (buildNodes == null) {
                return false;
            }

            BuildProcess buildProcess = new BuildProcess(this, buildOptions, buildResults);
            bool result = buildProcess.Run(action, buildNodes, processDependencies);
            return result;
        }


        //-- Members

        private bool m_explicitDepsComputed;
        private bool m_explicitDepsValid;

        private readonly HashSet<BuildTranslation> m_translations = new HashSet<BuildTranslation>();
        private readonly Dictionary<string, BuildFile> m_buildFiles = new Dictionary<string, BuildFile>();
    }
}
