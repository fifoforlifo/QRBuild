using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text.RegularExpressions;

using QRBuild.IO;

namespace QRBuild
{
    /// 
    public sealed class BuildGraph
    {
        //-- Public interface

        /// Execute the specified action on targets.
        /// This is how you kick off a Build.
        public BuildResults Execute(
            BuildAction action,
            BuildOptions buildOptions,
            IEnumerable<string> targetPaths,
            bool processDependencies)
        {
            Trace.TraceInformation("Execute {0}", action);
            Trace.TraceInformation("-----------");
            // TODO: trace targets

            BuildResults buildResults = new BuildResults();
            buildResults.Action = action;
            buildResults.ExecuteStartTime = DateTime.Now;

            buildResults.Success = UntimedExecute(
                action,
                buildOptions,
                targetPaths,
                processDependencies,
                buildResults);

            buildResults.ExecuteEndTime = DateTime.Now;
            return buildResults;
        }

        /// Returns all files that are not generated by this BuildGraph.
        /// This may be a very large collection.
        public ICollection<string> GetInputFilePaths(BuildOptions buildOptions)
        {
            ComputeDependencies(buildOptions);
            if (!m_dependenciesValid) {
                return null;
            }

            var inputs = new HashSet<string>();
            foreach (BuildFile buildFile in m_buildFiles.Values) {
                if (!IsBuildFileGenerated(buildFile)) {
                    inputs.Add(buildFile.Path);
                }
            }
            return inputs;
        }

        /// Returns all files that are generated by this BuildGraph.
        /// This may be a very large collection.
        public ICollection<string> GetOutputFilePaths(BuildOptions buildOptions)
        {
            ComputeDependencies(buildOptions);
            if (!m_dependenciesValid) {
                return null;
            }

            var inputs = new HashSet<string>();
            foreach (BuildFile buildFile in m_buildFiles.Values) {
                if (IsBuildFileGenerated(buildFile)) {
                    inputs.Add(buildFile.Path);
                }
            }
            return inputs;
        }

        public void GetInputsAndOutputsForTargets(
            BuildOptions buildOptions,
            IEnumerable<string> targetPaths,
            out HashSet<string> inputs,
            out HashSet<string> outputs)
        {
            inputs = new HashSet<string>();
            outputs = new HashSet<string>();

            ComputeDependencies(buildOptions);
            if (!m_dependenciesValid) {
                return;
            }

            HashSet<BuildFile> targets = GetBuildFilesForPaths(targetPaths);

            HashSet<BuildNode> buildNodes = GetBuildNodesForFiles(targets);
            if (buildNodes == null) {
                return;
            }

            BuildResults buildResults = new BuildResults();
            BuildProcess buildProcess = new BuildProcess(
                this,
                BuildAction.Build /* don't care */,
                buildOptions,
                buildResults /* don't care */,
                buildNodes,
                true /* processDependencies */);
            buildProcess.GetInputsAndOutputs(m_buildFiles.Values, inputs, outputs);
        }


        //-- Internal interface

        internal HashSet<BuildTranslation> Translations
        {
            get { return m_translations; }
        }

        /// Add a translation to the BuildGraph.
        /// BuildTranslation's constructor calls this, so that users don't have to.
        internal void Add(BuildTranslation translation)
        {
            m_dependenciesComputed = false;
            m_translations.Add(translation);
        }

        internal HashSet<BuildFile> GetBuildFilesForPaths(IEnumerable<string> filePaths)
        {
            HashSet<BuildFile> buildFiles = new HashSet<BuildFile>();
            foreach (string filePath in filePaths) {
                string absFilePath = QRPath.GetCanonical(filePath);

                BuildFile buildFile;
                if (m_buildFiles.TryGetValue(absFilePath, out buildFile)) {
                    buildFiles.Add(buildFile);
                }
                else {
                    // TODO: trace warning 
                }
            }
            return buildFiles;
        }

        internal BuildFile CreateOrGetBuildFile(string filePath)
        {
            BuildFile buildFile;
            if (m_buildFiles.TryGetValue(filePath, out buildFile)) {
                return buildFile;
            }
            buildFile = new BuildFile(filePath);
            m_buildFiles[filePath] = buildFile;
            return buildFile;
        }

        internal BuildFile GetBuildFile(string filePath)
        {
            BuildFile buildFile;
            m_buildFiles.TryGetValue(filePath, out buildFile);
            return buildFile;
        }


        //-- Helpers

        private static HashSet<BuildNode> GetBuildNodesForFiles(IEnumerable<BuildFile> files)
        {
            HashSet<BuildNode> result = new HashSet<BuildNode>();
            foreach (BuildFile file in files) {
                result.Add(file.BuildNode);
            }
            return result;
        }

        private static bool IsBuildFileGenerated(BuildFile buildFile)
        {
            bool result = (buildFile.BuildNode != null);
            return result;
        }

        /// Create a BuildFile for each output, and set its [generator] BuildNode.
        private bool AddOutputDependencies(BuildTranslation translation, IEnumerable<string> outputs)
        {
            bool result = true;
            foreach (string path in outputs) {
                BuildFile buildFile = CreateOrGetBuildFile(path);
                
                if (buildFile.BuildNode != null) {
                    Trace.TraceError("Target {0} claims to be generated by more than one Translation:\n\t{1}\n\t{2}\n",
                        buildFile.Path,
                        buildFile.BuildNode.Translation.BuildFileBaseName,
                        translation.BuildFileBaseName);
                    result = false;
                }
                else {
                    buildFile.BuildNode = translation.BuildNode;
                }
            }
            return result;
        }

        /// Update translation.BuildNode.Dependencies.
        private void AddInputDependencies(BuildTranslation translation, IEnumerable<string> inputs)
        {
            foreach (string input in inputs) {
                BuildFile buildFile = CreateOrGetBuildFile(input);
                buildFile.Consumers.Add(translation.BuildNode);

                if (buildFile.BuildNode != null) {
                    //  Add the BuildNode that generates input to the current node's dependency list.
                    translation.BuildNode.Dependencies.Add(buildFile.BuildNode);
                }
            }
        }

        private void TimedComputeDependencies(BuildResults buildResults, BuildOptions buildOptions)
        {
            buildResults.ComputeDependenciesStartTime = DateTime.Now;
            ComputeDependencies(buildOptions);
            buildResults.DependenciesValid = m_dependenciesValid;
            buildResults.ComputeDependenciesEndTime = DateTime.Now;
        }

        /// This function determines all BuildNodes' dependencies.
        /// Consumers are cleared here, to be decided later by the
        /// specific targets required of a BuildProcess.
        /// Call this after all Translations have been added.
        private void ComputeDependencies(BuildOptions buildOptions)
        {
            if (m_dependenciesComputed) {
                return;
            }
            m_dependenciesComputed = true;
            m_dependenciesValid = true;

            //  Clear m_buildFiles, so that we only use the most recent
            //  inputs and outputs from each BuildTranslation.
            m_buildFiles.Clear();

            Regex moduleNameRegex;
            if (String.IsNullOrEmpty(buildOptions.ModuleNameRegex)) {
                moduleNameRegex = new Regex(".*");
            }
            else {
                moduleNameRegex = new Regex(buildOptions.ModuleNameRegex);
            }

            //  Clear stale dependency information, and update each BuildNode's IOs.
            foreach (BuildTranslation translation in m_translations) {
                translation.BuildNode.Reset();

                bool moduleNameMatches = moduleNameRegex.IsMatch(translation.ModuleName);
                if (!moduleNameMatches) {
                    // Do not update BuildNode; this means this translation will
                    // not participate in the build at all.
                    continue;
                }

                if (translation.DepsCacheFilePath == null) {
                    Trace.TraceError("Translation {0} has null DepsCachePath.", translation.BuildFileBaseName);
                    return;
                }

                //  Update *current* explicit inputs and outputs.
                translation.UpdateExplicitIO();
                
                //  Load *previous* implicit inputs and outputs (for incremental building).
                //  TODO: parallelize deps cache file loading, or else we are I/O bound here
                //  depsCache file opened for exclusive access here.  We could also roll UpdateExplicitIO()
                //  into the parallel initialization, since each BuildNode is independent.
                QRDirectory.EnsureDirectoryExistsForFile(translation.DepsCacheFilePath);
                using (FileStream depsCacheFileStream = new FileStream(translation.DepsCacheFilePath, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.None)) {
                    string prevDepsCacheFileContents = QRFileStream.ReadAllText(depsCacheFileStream);
                    DependencyCache.LoadImplicitInputs(prevDepsCacheFileContents, translation.ImplicitInputs);
                }
            }

            //  Ensure existence of all BuildFile objects and BuildFile.BuildNode correctness.
            foreach (BuildTranslation translation in m_translations) {
                m_dependenciesValid &= AddOutputDependencies(translation, translation.ExplicitOutputs);
            }

            //  Establish BuildNode<->BuildNode dependencies based on inputs.
            foreach (BuildTranslation translation in m_translations) {
                AddInputDependencies(translation, translation.ExplicitInputs);
                AddInputDependencies(translation, translation.ImplicitInputs);
            }

            //  Establish consumers by reflecting the dependencies.
            foreach (BuildTranslation translation in m_translations) {
                foreach (BuildNode dependency in translation.BuildNode.Dependencies) {
                    dependency.Consumers.Add(translation.BuildNode);
                }
            }
        }

        private bool UntimedExecute(
            BuildAction action,
            BuildOptions buildOptions,
            IEnumerable<string> targetPaths,
            bool processDependencies,
            BuildResults buildResults)
        {
            TimedComputeDependencies(buildResults, buildOptions);
            if (!m_dependenciesValid) {
                return false;
            }

            HashSet<BuildFile> targets = GetBuildFilesForPaths(targetPaths);

            HashSet<BuildNode> buildNodes = GetBuildNodesForFiles(targets);
            if (buildNodes == null) {
                return false;
            }

            BuildProcess buildProcess = new BuildProcess(
                this,
                action,
                buildOptions,
                buildResults,
                buildNodes,
                processDependencies);
            bool result = buildProcess.Run();
            return result;
        }


        //-- Members

        private bool m_dependenciesComputed;
        private bool m_dependenciesValid;

        private readonly HashSet<BuildTranslation> m_translations = new HashSet<BuildTranslation>();
        private readonly Dictionary<string, BuildFile> m_buildFiles = new Dictionary<string, BuildFile>();
    }
}
